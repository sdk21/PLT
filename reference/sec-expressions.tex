\input{sec-expressions-table}
\subsection{Literals}
Literals are integers, floats, complex numbers, qubits, and matricies, as well as the built-in constants of the language (e.g. pi). Integers are of type int, floats are of type float, complex numbers are of type comp, qubits are of type qub, and matrices are of type mat. The built-in constants have pre-determined types described above (e.g. pi is of type float).\\\\
The remaining major subsections of this section describe the groups of expression operators, while the minor subsections describe the individual operators within a group.
\subsection{Primary Expressions}
\subsubsection{identifier}
Identifiers are primary expressions. All identifiers have an associated type that is given to them upon declaration (e.g. \textit{float ident} declares an identifier named ident that is of type float).
\subsubsection{literals}
Literals are primary expressions. They are described above.
\subsubsection{(expression)}
Parenthesized expressions are primary expressions. The type and value of a parenthesized expression is the same as the type and value of the expression without parenthesis. Parentheses allow expressions to be evaluated in a desired precedence. Parenthesized expressions are evaluated relative to each other starting with the expression that is nested the most deeply and ending with the expression that is nested the least deeply (i.e. the shallowest).
\subsubsection{primary-expression(expression-list)}
Primary expressions followed by a parenthesized expression list are primary expressions. Such primary expressions can be used in the declaration of functions or function calls. The expression list must consist of one or more expressions separated by commas. If being used in function declarations, they must be preceded by the correct function declaration syntax and each expression in the expression list must evaluate to a type followed by an identifier. If being used in function calls each expression in the expression list must evaluate to an identifier.
\subsubsection{[expression-elementlist]}
Expression element lists in brackets are primary expressions. Such primary expressions are used to define matrices and therefore are of type mat. The expression element list must consist of one or more expressions separated by commas or semi-colons. Commas separate expressions into matrix columns and semi-colons separate expressions into matrix rows. The expressions must evaluate to the same type and can be of type int, float, comp, or mat. Additionally, the number of expressions in each row of the matrix must be the same. An example matrix is shown below.

\begin{verbatim}
int a = 3;
int b = 12;
mat my_matrix = [ 0+1, 2, a; 5-1, 2*3-1, 12/2];
\end{verbatim}

\subsubsection{<expression|}
Expressions with a less than sign on the left and a bar on the right are primary expressions. Such expressions are used to define qubits and therefore are of type qub. The notation is meant to mimic the "bra-" of "bra-ket" notation and can therefore be thought of as a row vector representation of the given qubit. Following "bra-ket" notation, the expression must evaluate  to an integer literal of only 0's and 1's, which represents the state of the qubit. An example "bra-" qubit is shown below.

\begin{verbatim}
qub b_qubit = <0100|;
\end{verbatim}

\subsubsection{|expression>}
Expressions with a bar on the left and a greater than sign on the right are primary expressions. All of the considerations are the same as for <\textit{expression}|, except that this notation mimics the "ket" of "bra-ket" notation and can therefore be though of as a column vector representation of the given qubit. An example "ket-" qubit is shown below.

\begin{verbatim}
int a = 001;
qub k_qubit = |a>;
\end{verbatim}

\subsection{Unary Operators}
\subsubsection{not expression}
The result is a boolean indicating the logical \textit{not} of the expression. The type of the expression must be int or float. In the expressions, 0 is considered false and all other values are considered true.
\subsubsection{re expression}
The result is the real component of the expression. The type of the expression must be comp. The result has the same type as the expression (it is a complex number with  0 imaginary component).
\subsubsection{im expression}
The result is the imaginary component of the expression. The type of the expression must be comp. The result has the same type as the expression (it is a complex number with  0 real component).
\subsubsection{norm expression}
The result is the norm of the expression. The type of the expression must be mat. The result has type float if the expression is an integer matrix or float matrix and type comp if the expression is a complex number matrix.
\subsubsection{isunit expression}
The result is a boolean indicating if it is true or false that the expression is a unit matrix. The type of the expression must be mat.
\subsubsection{trans expression}
The result is the transpose of the expression. The type of the expression must be mat. The result has the same type as the expression.
\subsubsection{det expression}
The result is the determinant of the expression. The type of the expression must be mat. The result has type float if the expression is an integer matrix or float matrix and type comp if the expression is a complex number matrix.
\subsubsection{adj expression}
The result is the adjucate of the expression. The type of the expression must be mat. The result has the same type as the expression.
\subsubsection{conj expression}
The result is the complex conjugate of the expression. The type of the expression must be comp or mat. The result has type mat. The result has the same type as the expression.
\subsubsection{sin expression}
The result is the evaluation of the trigonometric function sine on the expression. The type of the expression must be int, float, or comp. The result has type float if the expression is of type int or float and type comp if the expression is of type comp.
\subsubsection{cos expression}
The result is the evaluation of the trigonometric function cosine on the expression. The type of the expression must be int, float, or comp. The result has type float if the expression is of type int or float and type comp if the expression is of type comp.
\subsubsection{tan expression}
The result is the evaluation of the trigonometric function tangent on the expression. The type of the expression must be int, float, or comp. The result has type float if the expression is of type int or float and type comp if the expression is of type comp.
\subsection{Binary Operators}
\subsubsection{expression $\hat{}$ expression}
The result is the exponentiation of the first expression by the second expression. The types of the expressions must be of type int, float, or comp. If the expressions are of the same type, the result has the same type as the expressions. Otherwise, if at least one expression is a comp, the result is of type comp; if neither expressions are comp, but at least one is float, the result is of type float.
\subsubsection{expression * expression}
The result is the product of the expressions. The type considerations are the same as they are for \textit{expression $\hat{}$ expression}
\subsubsection{expression / expression}
The result is the quotient of the expressions, where the first expression is the dividend and the second is the divisor. The type considerations are the same as they are for \textit{expression $\hat{}$ expression}. Integer division is rounded towards 0 and truncated.
\subsubsection{expression \% expression}
The result is the remainder of the division of the expressions, where the first expression is the dividend and the second is the divisor. The sign of the dividend and the divisor are ignored, so the result returned is always the remainder of the absolute value of the dividend divided by the absolute value of the divisor. The type considerations are the same as they are for \textit{expression $\hat{}$ expression}.
\subsubsection{expression + expression}
The result is the sum of the expressions. The types of the expressions must be of type int, float, comp, or qubit. Otherwise, if at least one expression is a comp, the result is of type comp; if neither expressions are comp, but at least one is float, the result is of type float. Qubits are special and can only be summed with each other.
\subsubsection{expression - expression}
The result is the difference of the first and second expressions. The type considerations are the same as they are for \textit{expression - expression}.
\subsubsection{expression @ expression}
The result is the tensor product of the first and second expressions. The The expressions must be of type of mat. The result has the same type as the expression.
\subsubsection{expression eq expression}
The result is a boolean indicating if it is true or false that the two expression are structurally equivalent. The type of the expressions must be the same.
\subsubsection{expression lt expression}
The result is a boolean indicating if it is true or false that the first expression is less than the second. The type of the expressions must be int, float, or comp and must be the same.
\subsubsection{expression gt expression}
The result is a boolean indicating if it is true or false that the first expression is greater than the second. The type of the expressions must be int, float, or comp and must be the same.
\subsubsection{expression leq expression}
The result is a boolean indicating if it is true or false that the first expression is less than  or equal to the second. The type of the expressions must be int, float, or comp and must be the same.
\subsubsection{expression geq expression}
The result is a boolean indicating if it is true or false that the first expression is greater than or equal to the second. The type of the expressions must be int, float, or comp and must be the same.
\subsubsection{expression or expression}
The result is a boolean indicating the logical \textit{or} of the expressions. The type of the expressions must be int or float and must be the same. In the expressions, 0 is considered false and all other values are considered true.
\subsubsection{expression and expression}
The result is a boolean indicating the logical \textit{and} of the expressions. The type considerations are the same as they are for \textit{expression or expression}.
\subsubsection{expression xor expression}
The result is a boolean indicating the logical \textit{xor} of the expressions. The type considerations are the same as they are for \textit{expression or expression}.
\subsection{Assignment Operators}
Assignment operators have left associativity
\subsubsection{lvalue $=$ expression}
The result is the assignment of the expression to the lvalue. The lvalue must have been previously declared. The type of the expression must be of the same that the lvalue was declared as. Recall, lvalues can be declared as int, float, comp, mat, and qubit.