\documentclass[11pt]{article}
\def\withcolors{0}
\def\withnotes{0}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{packages}
\input{preamble}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listings}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\small,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{OliveGreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=sh,                 % the language of the code
  morekeywords={def,elif,for, from, to, by,while,i, true, false},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{Gray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{RedViolet},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}



% These force using more of the margins that is the default style
\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\bra}[1]{\langle #1|}
\def\twobytwomatrix[#1,#2,#3,#4]{
\begin{bmatrix}
	#1 & #2 \\
	#3 & #4
\end{bmatrix}
}

\def\dotproduct[#1,#2]{
\langle #1 | #2 \rangle
}
\newcommand{\transpose}[1]{{#1}^{\rm T}} 			% shortcut
\newcommand{\adjoint}[1]{{#1}^{\dagger}} 			% shortcut
\newcommand{\QL}{\textsf{QLang}\xspace}

\begin{document}

% Everything after this becomes content
% Replace the text between curly brackets with your own
\title{Language Reference Manual \\ \vspace{2 mm} {\large QLang: Qubit Language}}
\author{
  Christopher Campbell
  \and Cl\'ement Canonne
  \and Sankalpa Khadka
  \and Winnie Narang
  \and Jonathan Wong
}
\date{\today}

% You can leave out ''date'' and it will be added automatically for today
% You can change the ''\today'' date to any text you like


\maketitle

% This command causes the title to be created in the document

\section{Introduction}

% An article style is separated into sections and subsections with 
%   markup such as this.  Use \section*{Principles} for unnumbered sections.
In 1965, Gordon Moore predicted that the number of transistors in integrated circuits would double every two years \cite{Moore:65}; up until now, this prediction has been seen to hold with quite an uncanny success. However, due to physical properties of the circuits, the classical architecture of computers cannot sustain such a increase rate.

Amongst the possible ``fixes'' that could allow the race for computational power to go on, a very promising candidate emerged from the last century's advances in Physics; namely, from the field of Quantum Mechanics. Since Richard Feynman suggested in 1982 a new paradigm of computation based on the laws of Quantum physics \cite{Feynman:82}, there has been great progress made in formulating the principles of \emph{quantum computers}, and in studying both their possibilities and limitations (see e.g. \cite{Shor:98,Williams:08,Nielsen:11}). The objective of this project is to design a language that exploits the mathematical foundations and syntax conventions of quantum computing to facilitate the simulation of quantum algorithms.

\subsection{Quantum computing}

In classical computing, data are stored in the form of binary digits or bits. A \emph{bit} is the basic unit of information stored and manipulated in a computer, which in one of two possible distinct states (for instance: two distinct voltages, on and off state of electric switch, two directions of magnetization, etc.). 
The two possible values/states of a system are represented as binary digits, $0$ and $1$.

\subsubsection{Qubit}
In a quantum computer, data are stored in the form of \emph{qubits}, or quantum bits. A quantum system of $n$ qubits is a Hilbert space of dimension $2^n$; fixing any orthonormal basis, any \emph{quantum state} can thus be uniquely written as a linear combination of $2^n$ orthogonal vectors $\{\ket{i}\}_i$ where $i$ is an $n$-bit binary number.

\begin{example}A $3$ qubit system has a canonical basis of 8 orthonormal states denoted 
$\ket{000}$, $\ket{001}$, $\ket{010}$, $\ket{011}$, $\ket{100}$, $\ket{101}$, $\ket{110}$, $\ket{111}$.
\end{example}
\paragraph{Upshot.} A classical bit has only two states, either $0$ or $1$. However a qubit can have  states $\ket{0}$ and $\ket{1}$, or any linear combination of states also known as a \emph{superposition}: %. Hence, a qubit can have an infinitely many states,
\[
	\ket{\phi}=\alpha\ket{0}+\beta\ket{1}
\]
where $\alpha,\beta\in\C$ are any complex numbers such that $\abs{\alpha}^2+\abs{\beta}^2=1$.

\subsubsection{Quantum Gates}
Logical operations, also known as \emph{logical gates}, are the basis of computation in classical computers. Computers are built with circuit that is made up of logical gates. The examples of logical gates are \textsf{AND}, \textsf{OR}, \textsf{NOT}, \textsf{NOR}, \textsf{XOR}, etc. Similarly,  a \emph{quantum gate} is an operation which is a \emph{unitary transformation} on qubits. The quantum gates are represented by matrices, and a gate acts on $n$ qubits is represented by $2^n \times 2^n$ unitary matrix\footnote{That is, a matrix $U\in\C^{2^n\times 2^n}$ such that $\adjoint{U}U=I_{2^n}$, where $\adjoint{\cdot}$ denotes the Hermitian conjugate.}. Analogous to the classical computer which is built from an electrical circuit containing wires and logic gates, quantum computers are built from  quantum circuits containing ``wires'' \ignore{(mostly photons)} and quantum gates to carry out the computation.\medskip

\noindent More on this, as well as the definition of the usual quantum gates; can be found in \autoref{app:quantum:more}.

\subsection {Dirac notation of quantum computation}
In quantum computing, \emph{Dirac notation} is used to represent qubits. Dirac notation provides concise and intuitive representation of complex matrix operations.

More precisely, a column vector $\left[ \begin {array} {c} c_1\\ c_2\\ \vdots\\ c_n \end{array} \right]$ is represented as $\ket{\psi}$, also read as ``ket psi''.  In particular, the computational basis states, also know as \emph{pure states} are represented as $\ket{i}$  where  $i$ is a $n$-bit binary number. For example,
\[
\ket{000}=\begin{bmatrix} 1\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0 \end{bmatrix},
\ket{001}=\begin{bmatrix} 0\\ 1\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0 \end{bmatrix},
\ket{010}=\begin{bmatrix} 0\\ 0\\ 1\\ 0\\ 0\\ 0\\ 0\\ 0 \end{bmatrix},
\dots,
\ket{101}=\begin{bmatrix} 0\\ 0\\ 0\\ 0\\ 0\\ 1\\ 0\\ 0 \end{bmatrix},
\ket{110}=\begin{bmatrix} 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 1\\ 0 \end{bmatrix},
\ket{111}=\begin{bmatrix} 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 1 \end{bmatrix}
\]
Similarly, the row vector $\begin{bmatrix} c^\ast_1 & c^\ast_2  & \dots & c^\ast_n & \end{bmatrix}$, which is also complex conjugate transpose of $\ket{\psi}$, is represented as $\bra{\psi}$, also read as ``bra psi''.\medskip

The inner product of vectors $\ket{\varphi}$ and $\ket{\psi}$ is written $\dotprod{ \varphi }{ \psi }$.
The tensor product of vectors $\ket{\varphi}$ and $\ket{\psi}$ is written $\ket{\varphi} \otimes \ket{\psi}$  and more commonly $\ket{\varphi}\ket{\psi}$.
We list below a few other mathematical notions that are relevant in quantum computing:

\begin{itemize}[-]
\item $z^\ast$ (complex conjugate of elements)\\  if $z=a+ib$, then $z^\ast = a - ib$.
\item $A^\ast$ (complex conjugate of matrices)\\ if $A = \twobytwomatrix[1,6i,3i,2+4i]$ then $A^\ast = \twobytwomatrix[1,-6i,-3i,2-4i]$.
%%%%%%%%%%%%%%%%%%%%%% Transpose of A
\item $\transpose{A}$  (transpose of matrix $A$)\\ if $A = \twobytwomatrix[1,6i,3i,2+4i]$ then $\transpose{A} = \twobytwomatrix[1,3i,6i,2+4i]$.
%%%%%%%%%%%%%%%%%%%%%% Adjoint of A
\item $\adjoint{A}$  (Hermitian conjugate (adjoint) of matrix $A$)\\
Defined as $\adjoint{A} = \left(\transpose{A}\right)^\ast$; if $A = \twobytwomatrix[1,6i,3i,2+4i]$ then $A^{\dag} = \twobytwomatrix[1,-3i,-6i,2-4i]$
%%%%%%%%%%%%%%%%%%%%%% Norm
\item $\norm{\ket{\psi}}$ ($\lp[2]$ norm of vector $\ket{\psi}$)\\
$\norm{\ket{\psi}} = \sqrt{\dotproduct[{\psi}, {\psi}]}$. 
 (This is often used to normalize $\ket{\psi}$ into a unit vector $\frac{\ket{\psi}}{\norm{\ket{\psi}}}$.)
%%%%%%%%%%%%%%%%%%%%%% Other

\item $\bra{\varphi}A\ket{\psi}$ (inner product of $\ket{\varphi}$ and $A\ket{\psi}$). \\
Equivalently\footnote{Recall that we work in a complex Hilbert space: the inner product is a sesquilinear form.}, inner product of $A^{\dag}\ket{\varphi}$ and $\ket{\psi}$

\end{itemize}

\subsection{Quantum Algorithms}
 %A quantum algorithm is a computation process that uses quantum computing to solve a problem.
 \new{A quantum algorithm is an algorithm that, in addition to operations on bits, can apply quantum gates to qubits and measure the outcome, in order to perform a computation or solve a search problem. Inherently, the outcome of such algorithms will be probabilistic.}%for instance, a quantum algorithm is said to \emph{compute a function $f$ on input $x$} if, for all $x$, the value $f(x)$ it outputs is correct with high probability.
  The representation of a quantum computation process requires an input register, output register and unitary transformation that takes a computational basis states into linear combination of computational basis states. If $x$ represents an $n$ qubit input register and $y$ represents an $m$ qubit output register, then the effect of a unitary transformation $U_f$ on the computational basis $\ket{x}_n\ket{y}_m$ is represented as follows:
	\begin{equation}
	U_f(\ket{x}_n\ket{y}_m)=\ket{x}_n\ket{y\oplus f(x)}_m,
	\end{equation}
	where $f$ is a function that takes an $n$ qubit input register and returns an $m$ qubit output and $\oplus$ represents mod-$2$ bitwise addition.
 \subsubsection{Deutsch-Jozsa Algorithm}
 Deutsch's Problem is an example of a quantum algorithm that performs computation in fewer steps than a classical computer.\\
 Suppose \new{$f\colon\{0,1\}^n \to \{0,1\}$ and that $f$ is either constant or balanced.}  The goal is determine which one it is.  Classically it is trivial to see that this would require (in worst case) querying just over half the solution space, or $2^{n-1} + 1$ queries.  The Deutsch-Jozsa algorithm answers this question with just {\it one} query!
 
\begin{figure}
\begin{center}
  \includegraphics{deutschjozsa}
\end{center}
\caption{Quantum Circuit for Deutsch-Jozsa Algorithm\label{m42}}
\end{figure}

\section {Qubit Language}
	
	The objective of \QL language is to allow simulation of quantum algorithm.
		
\subsection{Syntax}

An operation, or language elementary unit, starts from the end of the previous one, and ends whenever a semicolon or a line return is encountered. In particular, a semicolon at the end of the line is valid, yet not necessary.

\subsubsection{Comments}
Comments will be preceded by symbol \#; after the symbol, the remainder of the line is considered as a comment. No multiline comment is supported.
\begin{lstlisting}[frame=single]
	# This is just a comment.
\end{lstlisting}
	
\subsubsection {Variable Declaration}
Variables are declared with the name of the variable followed by equals and value assigned to the variable.

\begin{lstlisting}[frame=single]
	a = 5.9  
	b = 4+5i
	c = |00>
\end{lstlisting}

A variable name must start with a lower case letter, and can only contain \texttt{ASCII} characters: \texttt{a-aA-Z}, \texttt{0-9}, \_: that is, it must match the pattern \texttt{[a-z][a-zA-Z0-9\_]*}.

\subsubsection{Reserved keywords}
The following words are reserved, and cannot be variable \new{names: \texttt{i}, \texttt{if}, \texttt{elif}, \texttt{else}, \texttt{def}, \texttt{while}, \texttt{for}, \texttt{from}, \texttt{to}, \texttt{by}, \texttt{true}, \texttt{false}, as well as the identifiers of the builtin constructs of \autoref{ssec:operations}.}

\subsubsection{Data Types}

\begin{itemize}
\item Complex numbers\\
Quantum computation is done over complex vector space and hence one of the main data types  is complex number.

\begin{lstlisting}[frame=single]
	a = 5.9  
	b = 4+5i
\end{lstlisting}
All numbers are complex; the keyword \texttt{i} is reserved and refers to the usual value (imaginary unit $i$). By default, all numbers are internally stored as real numbers. \new{The implementation takes care of precision issues in a transparent fashion: the syntax does not differentiate between different floating-point precisions, and the programmer can implicitly assume all numbers have ``infinite precision''.} 

The two particular keywords \texttt{true} and \texttt{false} are constants, equal to respectively $1$ and $0$, and provided for notational convenience. Although we refer to them as Booleans, they are internally considered are complex numbers and can be used as such.

%\cnote{How do we want the precision to be handled? I'd love to have an exact, formal representation with no float/double loss; i.e., a formal representation. By default, integers or finite precision: whenever needed, the internal data type switches to the right representation, eg $\pi$ is representation formally as $\pi$, etc).}

\item Qubits \\
Qubit representation follows Dirac notation.\\

\begin{lstlisting}[frame=single]
	a=|1000>
	b =<001|
	c= |100> + | 110> 	 
\end{lstlisting}

\item Vector and Matrices \\
In essence, all data type are matrices.\\

\begin{lstlisting}[frame=single]
	a=[ 1, 1, 3]
	a=[ 1, 2, 3 ; 4, 5, 6; 7, 8, 9]
\end{lstlisting}

\end{itemize}

\subsubsection{Operations}\label{ssec:operations}
Mathematical operations such as multiplication, division, addition, tensor product matrix multiplication are supported by the language.
\begin{lstlisting}[frame=single]
	a = 5*5
 	b = 5*(6+7i)
	c = H|00>
  	d = |00> @ |1>
	M = [ 1, 2, 3 ; 4, 5, 6; 7, 8, 9]
	N = [1, 2; 5, 6]
	D = M @ N
\end{lstlisting}
Other builtin constructs are $\texttt{transp}$, $\texttt{adj}$, $\texttt{isunit}$, $\texttt{det}$ (for matrices), $\texttt{norm}$, $\texttt{conj}$ (for complex numbers). Note that no support by default is provided for matrix inversion; this choice is due to the fact that most matrices considered will (and have to) be unitary, in which case getting the inverse is straightforward which the above.

\subsubsection{Control Flow}

\begin{lstlisting}[frame=single]
	# if-elif-else statement
	if ( variable == true){
	}elif (boolean){
	}else{
	}
	#for loop, increment by 2 (the `by 2'' is optional
	for k from 1 to 10 by 2 {
	}
\end{lstlisting}
		
\subsubsection{Functions}

\begin{lstlisting}[frame=single]
	def output = function_name(args){
	}
\end{lstlisting}
	
\subsection{Simulation of Deutsch-Jozsa Algorithms} 

\begin{figure}
\begin{center}
\includegraphics{deutschjozsa}
\end{center}
\caption{ Quantum Circuit for Deutsch-Jozsa Algorithm
\label{m42}}
\end{figure}

\begin{lstlisting}[frame=single]
	def outcome = deutschjozsa(in-qubit, U-matrix){
		
		input-registers = in-qubit @ |1>;
		after-Hadamard = (H @ H)*(input-registers);
		after-U = U-matrix * after-Hadamard;
		after-Had = (H @ I)*after-U;
		M0=((in-qubit*(in-qubit)^H) @ I)*after-Had;
		
		if (M0 == 0){
			outcome = 0;
		}
		else{
			outcome = 1;
		}
	
	}
\end{lstlisting}
\newpage
\section* {The Team}

\begin{description}

\item[Manager:] Jonathan Wong
\item[Language Guru:] Sankalpa Khadka
\item[System Architect:] Winnie Narang
\item[System Integrator:] Cl\'ement Canonne
\item[Verification and Validation:] Christopher Campbell.
\end{description}
These roles are not definitive: each member of the team will work on every aspect of the project, while being the main responsible for its particular area.

\newpage
\nocite{*}
\bibliographystyle{alpha}
\bibliography{references}
\newpage
\appendix
\section{More on quantum computing and the underlying mathematics}\label{app:quantum:more}

\subsection {Common quantum gates}

\subsubsection*{Pauli Operators}
	The \emph{Pauli operators} are the special single qubit gates which are represented by the Pauli matrices $\{I, X, Y, Z\}$ as follows
	\[
I =
\begin{bmatrix}
 1 & 0  \\
 0 & 1  
\end{bmatrix}
\qquad
X =
\begin{bmatrix}
 0 & 1  \\
 1 & 0  
\end{bmatrix}
\qquad
Z =
\begin{bmatrix}
 1 & 0  \\
 0 & -1  
\end{bmatrix}
\qquad
Y =
\begin{bmatrix}
 0 & -i  \\
 i & 0  
\end{bmatrix}.
\]
For example, the application of $X$ causes bit-flip in following ways:
\[
X\ket{0}=\begin{bmatrix}
 0 & 1  \\
 1 & 0  
\end{bmatrix}
\begin{bmatrix}
 1   \\
 0   
\end{bmatrix}=\begin{bmatrix}
 0   \\
 1   
\end{bmatrix}= \ket{1}
\]
\[
X\ket{1}=\begin{bmatrix}
 0 & 1  \\
 1 & 0  
\end{bmatrix}
\begin{bmatrix}
 0   \\
 1   
\end{bmatrix}=\begin{bmatrix}
 1   \\
 0   
\end{bmatrix}= \ket{0}.
\]
\subsubsection*{Hadamard Gate}
The \emph{Hadamard gate} is defined by the matrix:
\[
H= \frac{1}{\sqrt{2}}\begin{bmatrix}
 1 & 1  \\
 1 & -1
\end{bmatrix}.
\]
The Hadamard gate maps the computational basis states into superposition of states. The Hadamard gate is significant since it produces maximally entangled states from basis states in the following ways:
\[
H\ket{0}=\frac{1}{\sqrt{2}}(\ket{0}+\ket{1})
\qquad
H\ket{1}=\frac{1}{\sqrt{2}}(\ket{0}-\ket{1}).
\]

\subsubsection*{Controlled-U Gates}
	A \emph{controlled-U gate} is the quantum gate in which the $U$ operator acts on the \new{$n$\textsuperscript{th} $n$-qubit} only if the value of the preceeding qubit is $1$.\\ For example: In a Controlled-\textsf{NOT} gate, the \textsf{NOT} operator flips the second qubit if the first qubit is $1$.
	\[
	\textsf{CNOT} = \begin{bmatrix}
 1&0&0&0\\
0&1&0&0\\
0&0&0&1 \\
0&0&1&0\end{bmatrix}
	\]
	
	\[
	\textsf{CNOT}\ket{00}=\ket{00}
	\]
	\[
	\textsf{CNOT}\ket{01}=\ket{01}
	\]
	\[
	\textsf{CNOT}\ket{10}=\ket{11}
	\]
	\[
	\textsf{CNOT}\ket{11}=\ket{10}.
	\]
	
	
\subsection {Tensor product and its properties}

Let $A=(a_{i,j})$ be a matrix with respect to the ordered basis $\mathcal{A}=(u_1,\dots,u_n)$ and $B=(b_{i,j})$ be a matrix with respect to the ordered basis $\mathcal{B}=(v_1,\dots,v_m)$. Consider the ordered basis $\mathcal{C}=(u_i \otimes v_j)$ ordered by lexicographic order, that is $u_i \otimes v_j \leq u_l \otimes v_k$ if if $i<l$ or $i=l$ and $j<k$. The matrix of $A \otimes B$ with respect to $\mathcal{C}$ is : 
\[
	A \otimes B= 
	\begin{bmatrix}
 	a_{1,1}B & a_{1,2}B & \dots & a_{1,n}B\\
	a_{2,1}B & a_{2,2}B & \dots & a_{2,n}B\\
	\vdots & \vdots & \ddots & \vdots \\
	a_{n,1}B & a_{n,2}B & \dots & a_{n,n}B
	\end{bmatrix} 
\]
		This matrix is called the tensor product of the matrix $A$ with the matrix $B$.
\begin{itemize}
\item $A \otimes B \otimes C =  (A \otimes B ) \otimes C = A \otimes (B \otimes C)$
\item $ a ( \ket{x} \otimes \ket{y}) = a \ket{x} \otimes \ket{y} = \ket{x} \otimes a\ket{y}$
\item $ ( A \otimes B) \cdot (\ket{y}\ket{z}) = A\ket{y} \otimes B\ket{z}$
\item $ ( A \otimes B) \cdot ( C \otimes D) = AC \otimes BD$
\item $ (A \otimes B) ^{H} = A^{H} \otimes B^{H}$
\item If $ A$ and $B$ unitary, $A \otimes B$ is unitary.
\item If $\ket{x}=\ket{x_1} \ket{x_2}$ and $\ket{y}=\ket{y_1}\ket{y_2}$ then $\dotproduct[x,y]=\dotproduct[x_1,y_1] \dotproduct[x_2, y_2]$ 
\end{itemize}
	
\end{document}
