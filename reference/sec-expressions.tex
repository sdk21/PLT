\input{sec-expressions-table}
The remaining major subsections of this section describe the groups of expression operators, while the minor subsections describe the individual operators within a group.
\subsection{Primary Expressions}
\subsubsection{identifier}
Identifiers are primary expressions. All identifiers have an associated type that is given to them upon declaration (e.g. \textit{float ident} declares an identifier named ident that is of type float).
\subsubsection{constant}
Constants are primary expressions. Constants are integer, float, complex number, qubit, and matrix literals as well as the built-in constants of the language (e.g. pi). All constants have an associated type that are predetermined by the language (e.g. integers are of type int). 
\subsubsection{(expression)}
Parenthesized expressions are primary expressions. The type and value of a parenthesized expression is the same as the type and value of the expression without parenthesis. Parentheses allow expressions to be evaluated in a desired precedence. Parenthesized expressions are evaluated relative to each other starting with the expression that is nested the most deeply and ending with the expression that is nested the least deeply (i.e. the shallowest).
\subsubsection{primary-expression[expression]}
Primary expressions followed by expressions in brackets are primary expressions. Such primary expressions represent indexing into an array, where the primary expression is the array and the expression in brackets is the index. Because indicies must be of type int, the expression in brackets must evaluate to an int. The evaluation of the overall primary expression should give the value associated with the given index of the array.
\subsubsection{primary-expression(expression-list)}
Primary expressions followed by a parenthesized expression list are primary expressions. The expression list is mandatory and must consist of one or more expressions separated by commas. Such primary expressions can be used in the declaration of functions or function calls. If being used in function declarations, they must be preceded by the correct function declaration syntax and each expression in the expression list must evaluate to a type followed by an identifier. If being used in function calls each expression in the expression list must evaluate to an identifier.
\subsection{Unary Operators}
\subsubsection{not expression}
The result is the negative of the expression. The type of the expression must be int or float. The result has the same type as the expression.
\subsubsection{re expression}
The result is the real component of the expression. The type of the expression must be comp. The result has the same type as the expression (it is a complex number with  0 imaginary component).
\subsubsection{im expression}
The result is the imaginary component of the expression. The type of the expression must be comp. The result has the same type as the expression (it is a complex number with  0 real component).
\subsubsection{norm expression}
The result is the norm of the expression. The type of the expression must be mat. The result has type int if the expression is an integer matrix, type float if the expression is a float matrix, and type comp if the expression is a complex number matrix.
\subsubsection{isunit expression}
The result is a boolean indicating if it is true or false that the expression is a unit matrix. The type of the expression must be mat.
\subsubsection{trans expression}
The result is the transpose of the expression. The type of the expression must be mat. The result has the same type as the expression.
\subsubsection{det expression}
The result is the determinant of the expression. The type of the expression must be mat. The result has type int if the expression is an integer matrix,  type float if the expression was a float matrix, and type comp if the expression was a complex number matrix.
\subsubsection{adj expression}
The result is the adjucate of the expression. The type of the expression must be mat. The result has the same type as the expression.
\subsubsection{conj expression}
The result is the complex conjugate of the expression. The type of the expression must be comp or mat. The result has type mat. The result has the same type as the expression.
\subsubsection{sin expression}
The result is the evaluation of the trigonometric function sine on the expression. The type of the expression must be int, float, or comp. The result has type float if the expression is of type int or float and type comp if the expression is of type comp.
\subsubsection{cos expression}
The result is the evaluation of the trigonometric function cosine on the expression. The type of the expression must be int, float, or comp. The result has type float if the expression is of type int or float and type comp if the expression is of type comp.
\subsubsection{tan expression}
The result is the evaluation of the trigonometric function tangent on the expression. The type of the expression must be int, float, or comp. The result has type float if the expression is of type int or float and type comp if the expression is of type comp.
\subsection{Binary Operators}
\subsubsection{expression $\hat{}$ expression}
The result is the exponentiation of the first expression by the second expression. The types of the expressions must be of type int, float, or comp. If the expressions are of the same type, the result has the same type as the expressions. Otherwise, if at least one expression is a comp, the result is of type comp; if neither expressions are comp, but at least one is float, the result is of type float.
\subsubsection{expression * expression}
The result is the product of the expressions. The type considerations are the same as they are for \textit{expression $\hat{}$ expression}
\subsubsection{expression / expression}
The result is the quotient of the expressions, where the first expression is the dividend and the second is the divisor. The type considerations are the same as they are for \textit{expression $\hat{}$ expression}. Integer division is rounded towards 0 and truncated.
\subsubsection{expression \% expression}
The result is the remainder of the division of the expressions, where the first expression is the dividend and the second is the divisor. The sign of the dividend and the divisor are ignored, so the result returned is always the remainder of the absolute value of the dividend divided by the absolute value of the divisor. The type considerations are the same as they are for \textit{expression $\hat{}$ expression}.
\subsubsection{expression + expression}
The result is the sum of the expressions. The types of the expressions must be of type int, float, comp, or qubit. Otherwise, if at least one expression is a comp, the result is of type comp; if neither expressions are comp, but at least one is float, the result is of type float. Qubits are special and can only be summed with each other.
\subsubsection{expression - expression}
The result is the difference of the first and second expressions. The type considerations are the same as they are for \textit{expression - expression}.
\subsubsection{expression @ expression}
The result is the tensor product of the first and second expressions. The The expressions must be of type of mat. The result has the same type as the expression.
\subsubsection{expression eq expression}
The result is a boolean indicating if it is true or false that the two expression are structurally equivalent. The type of the expressions must be the same.
\subsubsection{expression lt expression}
The result is a boolean indicating if it is true or false that the first expression is less than the second. The type of the expressions must be int, float, or comp and must be the same.
\subsubsection{expression gt expression}
The result is a boolean indicating if it is true or false that the first expression is greater than the second. The type of the expressions must be int, float, or comp and must be the same.
\subsubsection{expression leq expression}
The result is a boolean indicating if it is true or false that the first expression is less than  or equal to the second. The type of the expressions must be int, float, or comp and must be the same.
\subsubsection{expression geq expression}
The result is a boolean indicating if it is true or false that the first expression is greater than or equal to the second. The type of the expressions must be int, float, or comp and must be the same.
\subsubsection{expression or expression}
The result is a boolean indicating the logical \textit{or} of the expressions. The type of the expressions must be int or float and must be the same. In the expressions, 0 is considered false and all other values are considered true.
\subsubsection{expression and expression}
The result is a boolean indicating the logical \textit{or} of the expressions. The type of the expressions must be int or float and must be the same. In the expressions, 0 is considered false and all other values are considered true.
\subsubsection{expression xor expression}
The result is a boolean indicating the logical \textit{or} of the expressions. The type of the expressions must be int, float and must be the same. In the expressions, 0 is considered false and all other values are considered true.
\subsection{Assignment Operators}
Assignment operators have left associativity
\subsubsection{lvalue $=$ expression}
The result is the assignment of the expression to the lvalue. The lvalue must have been previously declared. The type of the expression must be of the same that the lvalue was declared as. Recall, lvalues can be declared as int, float, comp, mat, and qubit.